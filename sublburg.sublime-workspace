{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"file": "templates/blog/_article_list.html",
			"settings":
			{
				"buffer_size": 1261,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "from bot import create_neural_network, get_bot_response\nfrom worker import conn\nfrom author.decorators import login_required_check_confirmed, login_required\nfrom author.forms import ResetPasswordForm, ChangeUsernameForm\nfrom Blog.forms import PostForm, CommentForm\nfrom author.models import Author\nfrom Blog.models import Post, Category, Comment\nfrom application import db, create_app\nfrom flask import Blueprint, session, render_template, flash, redirect, url_for, request, jsonify\nfrom slugify import slugify\nfrom werkzeug.security import generate_password_hash\nimport uuid\nfrom PIL import Image, ExifTags\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nimport boto3\nimport io\nimport os\nfrom rq import Queue\nfrom rq.job import Job\n\nblog_app = Blueprint('blog_app', __name__)\n\n\nBUCKET_NAME = os.environ.get('BUCKET_NAME')\nlimiter = Limiter(\n    create_app(),\n    key_func=get_remote_address\n)\nPOSTS_PER_PAGE = 5\ns3 = boto3.resource('s3')\nq = Queue(connection=conn)\n\nmodel, words, labels = create_neural_network()\n\n\n@blog_app.route('/send_message', methods=['POST'])\ndef send_message():\n    user_inp = request.form['message']\n    bot_text = get_bot_response(model, words, labels, user_inp)\n    response_text = {\"message\": bot_text}\n    return jsonify(response_text)\n\n\n@blog_app.route('/redis')\ndef redis():\n    result = q.enqueue(redis_test)\n    return str(result)\n\n\n@blog_app.route('/results/<job_key>', methods=['GET'])\ndef results(job_key):\n    job = Job.fetch(job_key, connection=conn)\n\n    if job.is_finished:\n        return str(job.result), 200\n    else:\n        return \"Nay!\", 202\n\n\n@blog_app.route('/blog')\ndef index():\n    page = int(request.values.get('page', '1'))\n    posts = Post.query.filter_by(live=True).order_by(Post.publish_date.desc())\\\n        .paginate(page, POSTS_PER_PAGE, False)\n    return render_template('blog/index.html',\n                           posts=posts,\n                           title='Latest Posts')\n\n\n@blog_app.route('/profile', methods=['GET', 'POST'])\n@login_required_check_confirmed\ndef profile():\n    author = Author.query.get(session['id'])\n    posts = Post.query.filter_by(author_id=author.id).order_by(\n        Post.publish_date.desc())[:10]  # Last 10 posts from user\n\n    # forms that will be used for the modals on profile page.\n    password_form = ResetPasswordForm()\n    username_form = ChangeUsernameForm()\n\n    if password_form.validate_on_submit():\n        # generate hash from pass form data.\n        hashed_password = generate_password_hash(password_form.password.data)\n        author.password = hashed_password  # change authors password\n        db.session.commit()\n        flash(\"Password successfully changed.\", \"success\")\n\n    if username_form.validate_on_submit():\n        username = username_form.username.data\n        author.username = username\n        db.session.commit()\n        db.session.refresh(author)\n        flash(\"Username successfully changed.\", \"success\")\n\n    return render_template('blog/profile.html', posts=posts, password_form=password_form, username_form=username_form, author=author)\n\n\n@blog_app.route('/')\ndef landing():\n    return render_template('blog/landing_page.html')\n\n\n@blog_app.route('/post', methods=('GET', 'POST'))\n@login_required_check_confirmed\n@limiter.limit(\"5/hour\")\ndef post():\n    form = PostForm()\n\n    if form.validate_on_submit():\n        image_id = None\n\n        # create unique ID for image file_name. open image with PIL.\n        if form.image.data:\n            f = form.image.data\n            image_id = str(uuid.uuid4())\n            file_name = image_id + '.jpg'\n            img = Image.open(f)\n\n            # orientate & resize image\n            img = orientate_resize_image(img)\n\n            # Send the Bytes to S3\n            img_bytes = io.BytesIO()\n            img.save(img_bytes, format='JPEG')\n            s3_object = s3.Object(BUCKET_NAME, file_name)\n            s3_object.put(\n                Body=img_bytes.getvalue(),\n                ContentType='image/jpeg'\n            )\n\n        # Create new category in DB, if submitted in form.\n        if form.new_category.data:\n            new_category = Category(form.new_category.data)\n            db.session.add(new_category)\n            db.session.flush()\n            category = new_category\n        else:\n            category = form.category.data\n\n        author = Author.query.get(session['id'])\n        title = form.title.data.strip()\n        body = form.body.data.strip()\n        post = Post(\n            author=author,\n            title=title,\n            body=body,\n            image=image_id,\n            category=category\n        )\n\n        db.session.add(post)\n        db.session.commit()\n\n        slug = slugify(str(post.id) + \"-\" + post.title)\n        post.slug = slug\n        db.session.commit()\n\n        flash('Article Posted', 'success')\n        return redirect(url_for('.index'))\n\n    return render_template('blog/post.html', form=form, action='new')\n\n\n# no un-auth comments? all users must be signed up to comment.\n@blog_app.route('/posts/<slug>', methods=['GET', 'POST'])\n@login_required_check_confirmed\n@limiter.limit(\"20/hour\")\ndef article(slug):\n    form = CommentForm()\n    post = Post.query.filter_by(slug=slug).first()\n    prev_url = request.referrer\n\n    if form.validate_on_submit():\n        # query author ID so we can pass username into comment model.\n        author = Author.query.get(session['id'])\n        comment = Comment(\n            author.username,  # username of signed in user.\n            form.comment.data  # pull comment data from comment form\n        )\n\n        # append comment to post (comments field of the model)\n        post.comments.append(comment)\n        db.session.add(comment)\n        db.session.commit()\n        flash(\"Thank you for taking the time to comment.\", 'success')\n        return redirect(url_for('.article', slug=slug))\n\n    return render_template('blog/article.html', post=post, form=form, prev_url=prev_url)\n\n\n@blog_app.route('/edit/<slug>', methods=('GET', 'POST'))\n@login_required_check_confirmed\ndef edit(slug):\n    post = Post.query.filter_by(slug=slug).first_or_404()\n    form = PostForm(obj=post)\n\n    if form.validate_on_submit():\n        original_image = post.image\n        original_title = post.title\n        form.populate_obj(post)\n\n        if form.image.data:\n            f = form.image.data\n            image_id = str(uuid.uuid4())\n            file_name = image_id + '.jpg'\n            img = Image.open(f)\n\n            # orientate & resize image\n            img = orientate_resize_image(img)\n\n            # Send the Bytes to S3\n            img_bytes = io.BytesIO()\n            img.save(img_bytes, format='JPEG')\n            s3_object = s3.Object(BUCKET_NAME, file_name)\n            s3_object.put(\n                Body=img_bytes.getvalue(),\n                ContentType='image/jpeg'\n            )\n\n            post.image = image_id\n\n        else:\n            post.image = original_image\n\n        if form.new_category.data:\n            new_category = Category(form.new_category.data)\n            db.session.add(new_category)\n            db.session.flush()\n            post.category = new_category\n\n        if form.title.data != original_title:\n            post.slug = slugify(str(post.id) + '-' + form.title.data)\n\n        # Keeps session open for article view, or it bombs out.\n        session.expire_on_commit = False\n        db.session.commit()\n        flash('Article Edited', 'success')\n        return redirect(url_for('.article', slug=post.slug))\n\n    return render_template('blog/post.html', form=form, post=post, action='edit')\n\n\n@blog_app.route('/delete/<slug>')\n@login_required_check_confirmed\ndef delete(slug):\n    post = Post.query.filter_by(slug=slug).first_or_404()\n    post.live = False\n    db.session.commit()\n    flash('Article deleted', 'success')\n    return redirect(url_for('.index'))\n\n\n@blog_app.route('/categories/<category_id>')\ndef categories(category_id):\n    category = Category.query.filter_by(id=category_id).first_or_404()\n    page = int(request.values.get('page', '1'))\n    posts = category.posts.filter_by(live=True).order_by(\n        Post.publish_date.desc()).paginate(page, POSTS_PER_PAGE, False)\n    return render_template('blog/category_posts.html', posts=posts, title=category.name, category_id=category_id)\n\n\n# route for unconfirmed users. Will redirect to index if already confirmed.\n@blog_app.route('/unconfirmed')\n@login_required\ndef unconfirmed():\n    if (Author.query.get(session['id'])).confirmed is True:\n        return redirect(url_for('.index'))\n    return render_template('author/unconfirmed.html')\n\n\n@blog_app.errorhandler(429)\ndef ratelimit_handler(e):\n    flash(\"Please do not spam, come back in 1 hour.\", 'error')\n    return redirect(url_for('.index'))\n\n\ndef orientate_resize_image(img):\n    try:\n        for orientation in ExifTags.TAGS.keys():\n            if ExifTags.TAGS[orientation] == 'Orientation':\n                break\n        exif = dict(img._getexif().items())\n\n        if exif[orientation] == 3:\n            img = img.rotate(180, expand=True)\n        elif exif[orientation] == 6:\n            img = img.rotate(270, expand=True)\n        elif exif[orientation] == 8:\n            img = img.rotate(90, expand=True)\n\n    except (AttributeError, KeyError, IndexError):\n        # cases: image don't have getexif\n        pass\n\n    image_base = 600\n    wpercent = (image_base / float(img.size[0]))\n    hsize = int((float(img.size[1]) * float(wpercent)))\n    img = img.resize((image_base, hsize), Image.ANTIALIAS)\n\n    return img\n\n\ndef redis_test():\n    return [x for x in range(1, 10000)]\n",
			"file": "Blog/views.py",
			"file_size": 9918,
			"file_write_time": 132048183738686222,
			"settings":
			{
				"buffer_size": 9613,
				"encoding": "UTF-8",
				"line_ending": "Windows"
			}
		},
		{
			"file": "bot.py",
			"settings":
			{
				"buffer_size": 3347,
				"line_ending": "Windows"
			}
		},
		{
			"file": "requirements.txt",
			"settings":
			{
				"buffer_size": 1762,
				"encoding": "UTF-16 LE with BOM",
				"line_ending": "Windows"
			}
		},
		{
			"file": "templates/blog/index.html",
			"settings":
			{
				"buffer_size": 830,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"remove",
				"Package Control: Remove Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"Package Control: insta",
				"Package Control: Install Package"
			],
			[
				"Package Control: remove",
				"Package Control: Remove Package"
			],
			[
				"Package Control: rem",
				"Package Control: Remove Package"
			],
			[
				"package in",
				"Package Control: Install Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"Package Control: in",
				"Package Control: Install Package"
			],
			[
				"install pack",
				"Package Control: Install Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 157.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) "
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/Joel/Github/burgercraft",
		"/C/Users/Joel/Github/burgercraft/Blog",
		"/C/Users/Joel/Github/burgercraft/migrations",
		"/C/Users/Joel/Github/burgercraft/templates",
		"/C/Users/Joel/Github/burgercraft/templates/blog"
	],
	"file_history":
	[
		"/C/Users/Joel/AppData/Roaming/Sublime Text 3/Packages/AutoPEP8/AutoPep8.sublime-settings",
		"/C/Users/Joel/AppData/Roaming/Sublime Text 3/Packages/User/AutoPep8.sublime-settings",
		"/C/Users/Joel/AppData/Roaming/Sublime Text 3/Packages/AutoPEP8/Default.sublime-keymap",
		"/C/Users/Joel/AppData/Roaming/Sublime Text 3/Packages/SublimeCodeIntel/SublimeCodeIntel.sublime-settings",
		"/C/Users/Joel/AppData/Roaming/Sublime Text 3/Packages/User/SublimeCodeIntel.sublime-settings",
		"/C/Users/Joel/Github/flasky/app.py",
		"/C/Users/Joel/AppData/Roaming/Sublime Text 3/Packages/User/Pylinter.sublime-settings",
		"/C/Users/Joel/OneDrive/Kali/sendemail",
		"/C/Users/Joel/Desktop/Python/hello.py"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 2,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "templates/blog/_article_list.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1261,
						"regions":
						{
						},
						"selection":
						[
							[
								1164,
								1164
							]
						],
						"settings":
						{
							"syntax": "Packages/HTML/HTML.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Blog/views.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9613,
						"regions":
						{
						},
						"selection":
						[
							[
								4806,
								4806
							]
						],
						"settings":
						{
							"auto_complete": false,
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3525.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "bot.py",
					"semi_transient": true,
					"settings":
					{
						"buffer_size": 3347,
						"regions":
						{
						},
						"selection":
						[
							[
								226,
								226
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "requirements.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1762,
						"regions":
						{
						},
						"selection":
						[
							[
								670,
								670
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 70.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "templates/blog/index.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 830,
						"regions":
						{
						},
						"selection":
						[
							[
								364,
								364
							]
						],
						"settings":
						{
							"syntax": "Packages/HTML/HTML.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.autopep8":
	{
		"height": 164.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "sublburg.sublime-project",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 246.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
